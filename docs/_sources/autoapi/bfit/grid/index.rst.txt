:py:mod:`bfit.grid`
===================

.. py:module:: bfit.grid

.. autoapi-nested-parse::

   Grid module for integration.

   ..
       !! processed by numpydoc !!


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   bfit.grid.UniformRadialGrid
   bfit.grid.ClenshawRadialGrid
   bfit.grid.CubicGrid




.. py:class:: UniformRadialGrid(num_pts, min_radii=0.0, max_radii=100.0, dtype=np.longdouble)

   Bases: :py:obj:`_BaseRadialGrid`

   Uniformly Distributed Radial Grid Class.

   The grid points are equally-spaced in :math:`[0, K)` interval, where K is the upper bound
   on the grid.


   Construct the UniformRadialGrid object.

   :param num_pts: The number of grid points.
   :type num_pts: int
   :param min_radii: The smallest radial grid point.
   :type min_radii: float, optional
   :param max_radii: The largest radial grid point.
   :type max_radii: float, optional
   :param dtype: The desired NumPy data-type.
   :type dtype: data-type, optional















   ..
       !! processed by numpydoc !!

   .. py:method:: points(self)
      :property:

      
      Radial grid points.
















      ..
          !! processed by numpydoc !!

   .. py:method:: integrate(self, arr)

      
      Compute trapezoidal integration of a function evaluated on the radial grid points.

      In other words, :math:`\int f(r) dr`, where :math:'f(r)' is the integrand.

      :param arr: The integrand evaluated on the :math:`N` radial grid points.
      :type arr: ndarray(N,)

      :returns: The value of the integral.
      :rtype: float















      ..
          !! processed by numpydoc !!


.. py:class:: ClenshawRadialGrid(atomic_number, num_core_pts, num_diffuse_pts, extra_pts=None, include_origin=True, dtype=np.longdouble)

   Bases: :py:obj:`_BaseRadialGrid`

   Clenshaw-Curtis Radial Grid Class.

   The Clenshaw-Curtis grid places more points closer to the origin of the interval
   :math:`[0, \inf).`
   It is defined as follows. Let :math:`Z, m, n` be the atomic number, number of points near
   the origin, and the number of points far from the origin, respectively.

   Then each point :math:`r_p` of the Clenshaw radial grid is either

   .. math::
       \begin{eqnarray}
           r_p = \frac{1}{2Z} \bigg(1 - \cos\bigg(\frac{\pi p}{400} \bigg)\bigg)  &
           p = 0, 1, \cdots, m - 1 \\
           r_p = 25 \bigg(1 - \cos\bigg(\frac{\pi p}{600} \bigg)\bigg) & p = 1, \cdots, n - 1\\
       \end{eqnarray}


   Construct ClenshawRadialGrid grid object.

   :param atomic_number: The atomic number of the atom for which the grid is generated.
   :type atomic_number: int
   :param num_core_pts: The number of points near the origin/core region.
   :type num_core_pts: int
   :param num_diffuse_pts: The number of points far from the origin/core region.
   :type num_diffuse_pts: int
   :param extra_pts: Additional points to be added to the grid, commonly points far away from origin.
   :type extra_pts: list
   :param include_origin: If true, then include the origin :math:`r=0`.
   :type include_origin: bool
   :param dtype: The desired NumPy data-type.
   :type dtype: data-type, optional















   ..
       !! processed by numpydoc !!

   .. py:method:: atomic_number(self)
      :property:

      
      Return the atomic number.
















      ..
          !! processed by numpydoc !!

   .. py:method:: points(self)
      :property:

      
      Radial grid points.
















      ..
          !! processed by numpydoc !!

   .. py:method:: integrate(self, arr)

      
      Compute trapezoidal integration of a function evaluated on the radial grid points.

      In other words, :math:`\int f(r) dr`, where :math:'f(r)' is the integrand.

      :param arr: The integrand evaluated on the :math:`N` radial grid points.
      :type arr: ndarray(N,)

      :returns: The value of the integral.
      :rtype: float















      ..
          !! processed by numpydoc !!


.. py:class:: CubicGrid(origin, axes, shape)

   Equally-Spaced 3D Cubic Grid Class.


   Construct the CubicGrid object.

   :param origin: The origin (left-most, down-most) of the 3D cubic grid.
   :type origin: float
   :param axes: The axes that point to the direction of the grid.
   :type axes: ndarray(3, 3)
   :param shape: The number of points in each axes.
   :type shape: (int, int, int)















   ..
       !! processed by numpydoc !!

   .. py:method:: axes(self)
      :property:

      
      Return the axes/three-directions of the cubic grid.
















      ..
          !! processed by numpydoc !!

   .. py:method:: from_molecule(cls, atcorenums, atcoords, spacing=0.2, extension=5.0, rotate=True)
      :classmethod:

      
      Construct a uniform grid given the molecular pseudo-numbers and coordinates.

      :param atcorenums: Pseudo-number of :math:`M` atoms in the molecule.
      :type atcorenums: np.ndarray, shape (M,)
      :param atcoords: Cartesian coordinates of :math:`M` atoms in the molecule.
      :type atcoords: np.ndarray, shape (M, 3)
      :param spacing: Increment between grid points along :math:`x`, :math:`y`, and :math:`z` direction.
      :type spacing: float, optional
      :param extension: The extension of the length of the cube on each side of the molecule.
      :type extension: float, optional
      :param rotate: When True, the molecule is rotated so the axes of the cube file are
                     aligned with the principle axes of rotation of the molecule.
                     If False, generates axes based on the x,y,z-axis and the spacing parameter, and
                     the origin is defined by the maximum/minimum of the atomic coordinates.
      :type rotate: bool, optional















      ..
          !! processed by numpydoc !!

   .. py:method:: points(self)
      :property:

      
      Return cubic grid points.
















      ..
          !! processed by numpydoc !!

   .. py:method:: integrate(self, arr)

      
      Compute the integral of a function evaluated on the grid points based on Riemann sums.

      .. math::
          \int\int\int f(x, y, z) dx dy dz \approx \sum_i \sum_j \sum_k f(x_i, y_j, z_k) w_{ijk}

      where :math:'f(r)' is the integrand, and :math:`w_{ijk}` is the weight associated with
      the (i, j, k)th point.

      :param arr: The integrand evaluated on the grid points.
      :type arr: ndarray

      :returns: **value** -- The value of the integral.
      :rtype: float















      ..
          !! processed by numpydoc !!


